(每一步都是一个方法)
第一步获取资源路径Application.datepath+资源文件夹
(可以做一个判断，是否存在该文件夹)
定义存储文件路径的数据结构(如字典)
{
(打包的规则为：资源文件夹下每一个子文件夹为一个Bundle包，资源文件中的资源文件为单独一个bundle包)
第二步开始对文件进行分析(path,字典)
(可再次判断是否有该资源文件)
进行资源文件的打包
{
第三步打开该文件夹获取文件(path)
(可做一个判断该文件夹中的文件是否小于0弹出)
定义包名：(规则为在资源文件下为一个名字，不在则取截取上文获取的文件夹到+资源文件+"/"的位置
	注意需要转换为小写在字符替换"\\"替换为"/"，最后获取哈希值+后缀)
	我们还可以根据文件定义规则对名称进行其他规定
定义一个存储prefab路径资源数据结构
然后进行文件的遍历来判断资源是否为prefab资源是进行名字定义，不是下一次循环
资源名称定义：Assets/一直到自己的位置(注意需要字符替换)
判断上文路径是否有值，有把包名，list路径传入字典
}
获取path的文件路径进行遍历
使用递归再次进行第二步(path/子文件夹，字典)
}
由Application.streamingAssetsPath+"自定义文件名"获取或创建出存储bundle包文件夹路径
定义出AssetBundleBuild的数组、集合都可以
进行遍历字典
创建实例存储起来直至全部遍历
 BuildPipeline.BuildAssetBundles打包方法传入：文件名，AssetBundleBuild数组类型，		     BuildAssetBundleOptions.ChunkBasedCompression，平台
然后删除build包多余文件如：.mainfest,.mainfest.meta为后缀的文件
第四步创建比对文件
在build创建出不对文件该文件无后缀
定义需要写入的字符
打开资源文件夹获取到文件
遍历文件
打开该文件流获取到其中的MD5值写入字符直至完成
在把该字符写入到比对文件流。
打包完成！！！